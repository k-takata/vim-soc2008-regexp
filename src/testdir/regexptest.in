Test for regexp patterns.

A pattern that gives the expected result produces OK, so that we know it was
actually tried.

STARTTEST
:so small.vim
:" tl is a List of Lists with:
:"    regexp pattern
:"    text to test the pattern on
:"    expected match (optional)
:"    expected submatch 1 (optional)
:"    expected submatch 2 (optional)
:"    etc.
:"  When there is no match use only the first two items.
:let tl = []

:""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
:""""" Simple tests, with default magic option \m """""""""""""
:""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

:" Search single groups
:call add(tl, ['ab', 'aab', 'ab'])
:call add(tl, ['ab', 'baced'])
:call add(tl, ['ab', '                    ab           ', 'ab'])

:" Search multi-modifiers
:call add(tl, ['x*', 'xcd', 'x'])   
:call add(tl, ['x*', 'xxxxxxxxxxxxxxxxsofijiojgf', 'xxxxxxxxxxxxxxxx'])
:call add(tl, ['x*', 'abcdoij', ''])                    " empty match is good
:call add(tl, ['x\+', 'abcdoin'])                       " no match here
:call add(tl, ['x\+', 'abcdeoijdfxxiuhfij', 'xx'])
:call add(tl, ['x\+', 'xxxxx', 'xxxxx'])
:call add(tl, ['x\+', 'abc x siufhiush xxxxxxxxx', 'x'])
:call add(tl, ['x\=', 'x sdfoij', 'x'])
:call add(tl, ['x\=', 'abc sfoij', '']) " empty match is good
:call add(tl, ['x\=', 'xxxxxxxxx c', 'x'])
:call add(tl, ['x\?', 'x sdfoij', 'x'])
:call add(tl, ['x\?', 'abc sfoij', ''])                 " empty match is good
:call add(tl, ['x\?', 'xxxxxxxxxx c', 'x'])

:call add(tl, ['a\{0,0}', 'abcdfdoij', '']) 
:call add(tl, ['a\{0,1}', 'asiubid axxxaaa', 'a'])      " same thing as 'a?'
:call add(tl, ['a\{1,0}', 'asiubid axxxaaa', 'a'])      " same thing as 'a\{0,1}'
:call add(tl, ['a\{3,6}', 'aa siofuh'])
:call add(tl, ['a\{3,6}', 'aaaaa asfoij afaa', 'aaaaa'])
:call add(tl, ['a\{3,6}', 'aaaaaaaa', 'aaaaaa'])
:call add(tl, ['a\{0}', 'asoiuj', ''])
:call add(tl, ['a\{2}', 'aaaa', 'aa'])
:call add(tl, ['a\{2}', 'iuash fiusahfliusah fiushfilushfi uhsaifuh askfj nasfvius afg aaaa sfiuhuhiushf', 'aa'])
:call add(tl, ['a\{2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])
:call add(tl, ['a\{0,}', 'oij sdigfusnf', ''])          " same thing as 'a*'
:call add(tl, ['a\{0,}', 'aaaaa aa', 'aaaaa'])
:call add(tl, ['a\{2,}', 'sdfiougjdsafg'])
:call add(tl, ['a\{2,}', 'aaaaasfoij ', 'aaaaa'])
:call add(tl, ['a\{,0}', 'oidfguih iuhi hiu aaaa', ''])
:call add(tl, ['a\{,5}', 'abcd', 'a'])
:call add(tl, ['a\{,5}', 'aaaaaaaaaa', 'aaaaa'])
:call add(tl, ['a\{}', 'bbbcddiuhfcd', ''])                 " same thing as 'a*'
:call add(tl, ['a\{}', 'aaaaioudfh coisf jda', 'aaaa'])

:call add(tl, ['a\{-0,0}', 'abcdfdoij', '']) 
:call add(tl, ['a\{-0,1}', 'asiubid axxxaaa', ''])      " anti-greedy version of 'a?'
:call add(tl, ['a\{-3,6}', 'aa siofuh'])
:call add(tl, ['a\{-3,6}', 'aaaaa asfoij afaa', 'aaa'])
:call add(tl, ['a\{-3,6}', 'aaaaaaaa', 'aaa'])
:call add(tl, ['a\{-0}', 'asoiuj', ''])
:call add(tl, ['a\{-2}', 'aaaa', 'aa'])
:call add(tl, ['a\{-2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])
:call add(tl, ['a\{-0,}', 'oij sdigfusnf', ''])
:call add(tl, ['a\{-0,}', 'aaaaa aa', ''])
:call add(tl, ['a\{-2,}', 'sdfiougjdsafg'])
:call add(tl, ['a\{-2,}', 'aaaaasfoij ', 'aa'])
:call add(tl, ['a\{-,0}', 'oidfguih iuhi hiu aaaa', ''])
:call add(tl, ['a\{-,5}', 'abcd', ''])
:call add(tl, ['a\{-,5}', 'aaaaaaaaaa', ''])
:call add(tl, ['a\{-}', 'bbbcddiuhfcd', ''])            " anti-greedy version of 'a*'
:call add(tl, ['a\{-}', 'aaaaioudfh coisf jda', ''])

:call add(tl, ['abc\@=', 'abc', 'ab'])
:call add(tl, ['abc\@=cd', 'abcd', 'abcd'])
:call add(tl, ['abc\@=', 'ababc', 'ab'])
:call add(tl, ['abcd\@=e', 'abcd'])                     " will never match, no matter the input text
:call add(tl, ['abcd\@=e', 'any text in here ... '])    " will never match
:call add(tl, ['abc\@!', 'abc'])
:call add(tl, ['abc\@!', 'abd', 'ab'])
:call add(tl, ['c\@<=test', 'abctest', 'test'])
:call add(tl, ['c\@<=test', 'abcdtest'])
:call add(tl, ['c\@<!haha', 'chaha'])
:call add(tl, ['c\@<!haha', 'abcd haha', 'haha'])
:call add(tl, ['xyz\@>cd', 'xyzcd', 'xyzcd'])
:call add(tl, ['xyz\@>cd', 'xyzc'])

:" Test groups of characters and submatches
:call add(tl, ['\(abc\)*', 'abcabcabc', 'abcabcabc', 'abc'])
:call add(tl, ['\(ab\)\+', 'abababaaaaa', 'ababab', 'ab'])
:call add(tl, ['\(abaaaaa\)*cd', 'cd', 'cd', ''])
:call add(tl, ['\(test1\)\? \(test2\)\?', 'test1 test3', 'test1 ', 'test1', ''])
:call add(tl, ['\(test1\)\= \(test2\) \(test4443\)\=', ' test2 test4443 yupiiiiiiiiiii', ' test2 test4443', '', 'test2', 'test4443'])
:call add(tl, ['\(\(sub1\) hello \(sub 2\)\)', 'asterix sub1 hello sub 2 obelix', 'sub1 hello sub 2', 'sub1 hello sub 2', 'sub1', 'sub 2'])
:call add(tl, ['\(\(\(yyxxzz\)\)\)', 'abcdddsfiusfyyzzxxyyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz'])
:call add(tl, ['\v((ab)+|c+)+', 'abcccaba', 'abcccab', 'ab', 'ab'])
:call add(tl, ['\v((ab)|c*)+', 'abcccaba', 'abcccab', '', 'ab'])
:call add(tl, ['\v(a(c*)+b)+', 'acbababaaa', 'acbabab', 'ab', ''])
:call add(tl, ['\v(a|b*)+', 'aaaa', 'aaaa', ''])

:" Test greedy-ness and lazy-ness
:call add(tl, ['a\{-2,7}','aaaaaaaaaaaaa', 'aa'])
:call add(tl, ['a\{2,7}','aaaaaaaaaaaaaaaaaaaa', 'aaaaaaa'])
:call add(tl, ['\vx(.{-,8})yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz','ayxa','xayzxayz'])
:call add(tl, ['\vx(.*)yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz', 'ayxayzxayzxa',''])
:call add(tl, ['\v(a{1,2}){-2,3}','aaaaaaa','aaaa','aa'])
:call add(tl, ['\v(a{-1,3})+','aa','aa','a'])

:" Test Character classes 
:call add(tl, ['\d\+e\d\d','test 10e23 fd','10e23'])

:" Test character range []
:call add(tl, ['\v[a]', 'abcd', 'a'])
:call add(tl, ['a[bcd]', 'abcd', 'ab'])
:call add(tl, ['a[b-d]', 'acbd', 'ac'])
:call add(tl, ['[a-d][e-f][x-x]d', 'cexdxx', 'cexd'])
:call add(tl, ['\v[[:alpha:]]+', 'abcdefghijklmnopqrstuvwxyz6','abcdefghijklmnopqrstuvwxyz'])
:call add(tl, ['[[:alpha:]\+]', '6x8','x'])
:call add(tl, ['[^abc]\+','abcabcabc'])
:call add(tl, ['[^abc]','defghiasijvoinasoiunbvb','d'])
:call add(tl, ['[^abc]\+','ddddddda','ddddddd'])
:call add(tl, ['[^a-d]\+','aaaAAAZIHFNCddd','AAAZIHFNC'])
:call add(tl, ['[a-f]*','iiiiiiii',''])
:call add(tl, ['[a-f]*','abcdefgh','abcdef'])
:call add(tl, ['[^a-f]\+','abcdefgh','gh'])
:call add(tl, ['[a-c]\{-3,6}','abcabc','abc'])
:call add(tl, ['[^[:alpha:]]\+','abcccadfoij7787ysf287yrnccdu','7787'])
:call add(tl, ['[-a]', '-', '-'])
:call add(tl, ['[a-]', '-', '-'])
:call add(tl, ['[-./[:alnum:]_~]\+', 'log13.file', 'log13.file'])		" filename regexp
:call add(tl, ['[\]\^\-\\]\+', '\^\\\-\---^', '\^\\\-\---^'])			" special chars 
:call add(tl, ['[[.a.]]\+', 'aa', 'aa'])								" collation elem
:call add(tl, ['[[=a=]]\+', 'ddaãâbcd', 'aãâ'])							" equivalence classes
:call add(tl, ['abc[0-9]*ddd', 'siuhabc ii'])							" middle of regexp
:call add(tl, ['abc[0-9]*ddd', 'adf abc44482ddd oijs', 'abc44482ddd'])

:"""" Test recognition of some character classes
:call add(tl, ['[0-9]', '8', '8'])
:call add(tl, ['[^0-9]', '8'])
:call add(tl, ['[0-9a-fA-F]*', '0a7', '0a7'])
:call add(tl, ['[^0-9A-Fa-f]\+', '0a7'])
:call add(tl, ['[a-z_A-Z0-9]\+', 'aso_sfoij', 'aso_sfoij'])
:call add(tl, ['[a-z]', 'a', 'a'])
:call add(tl, ['[a-zA-Z]', 'a', 'a'])
:call add(tl, ['[A-Z]', 'a'])
:call add(tl, ['\C[^A-Z]\+', 'ABCOIJDEOIFNSD jsfoij sa', ' jsfoij sa'])

:"""" TODO: Write tests for \@ features
:"""" TODO: Write more tests for groups, and submatches

:"""" Combining different tests and features
:call add(tl, ['[[:alpha:]]\{-2,6}', '787abcdiuhsasiuhb4', 'ab'])
:call add(tl, ['[^[=a=]]\+', 'ddaãâbcd', 'dd'])							" equivalence classes + not
:call add(tl, ['[[:alpha:][=a=]]\+', '879 aiaãâaiuvna ', 'aiaãâaiuvna'])

:"""" Debugging tests


:"
:for t in tl
:  let l = matchlist(t[1], t[0])
:" check the match itself
:  if len(l) == 0 && len(t) > 2
:    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", did not match, expected: \"' . t[2] . '\"'
:  elseif len(l) > 0 && len(t) == 2
:    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", match: \"' . l[0] . '\", expected no match'
:  elseif len(t) > 2 && l[0] != t[2]
:    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", match: \"' . l[0] . '\", expected: \"' . t[2] . '\"'
:  else
:    $put ='OK - ' . t[0]
:  endif
:  if len(l) > 0
:"   check all the nine submatches
:    for i in range(1, 9)
:      if len(t) <= i + 2
:        let e = ''
:      else
:        let e = t[i + 2]
:      endif
:      if l[i] != e
:        $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", submatch ' . i . ': \"' . l[i] . '\", expected: \"' . e . '\"'
:      endif
:    endfor
:    unlet i
:  endif
:endfor
:unlet t tl e l 

/\%#=1
:/^Results/,$wq! test.out
ENDTEST

Results of regexptest:
