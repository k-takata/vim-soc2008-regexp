Test for regexp patterns.

A pattern that gives the expected result produces OK, so that we know it was
actually tried.

STARTTEST
:so small.vim
:" tl is a List of Lists with:
:"    regexp pattern
:"    text to test the pattern on
:"    expected match (optional)
:"    expected submatch 1 (optional)
:"    expected submatch 2 (optional)
:"    etc.
:"  When there is no match use only the first two items.
:let tl = []

:""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
:""""" Simple tests, with default magic option \m """""""""""""
:""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

:" Search single groups
:call add(tl, ['ab', 'aab', 'ab'])
:call add(tl, ['ab', 'baced'])
:call add(tl, ['ab', '                    ab           ', 'ab'])

:" Search multi-modifiers
:call add(tl, ['x*', 'xcd', 'x'])   
:call add(tl, ['x*', 'xxxxxxxxxxxxxxxxsofijiojgf', 'xxxxxxxxxxxxxxxx'])
:call add(tl, ['x*', 'abcdoij', ''])                    " empty match is good
:call add(tl, ['x\+', 'abcdoin'])                       " no match here
:call add(tl, ['x\+', 'abcdeoijdfxxiuhfij', 'xx'])
:call add(tl, ['x\+', 'xxxxx', 'xxxxx'])
:call add(tl, ['x\+', 'abc x siufhiush xxxxxxxxx', 'x'])
:call add(tl, ['x\=', 'x sdfoij', 'x'])
:call add(tl, ['x\=', 'abc sfoij', '']) " empty match is good
:call add(tl, ['x\=', 'xxxxxxxxx c', 'x'])
:call add(tl, ['x\?', 'x sdfoij', 'x'])
:call add(tl, ['x\?', 'abc sfoij', ''])                 " empty match is good
:call add(tl, ['x\?', 'xxxxxxxxxx c', 'x'])

:call add(tl, ['a\{0,0}', 'abcdfdoij', '']) 
:call add(tl, ['a\{0,1}', 'asiubid axxxaaa', 'a'])      " same thing as 'a?'
:call add(tl, ['a\{1,0}', 'asiubid axxxaaa', 'a'])      " same thing as 'a\{0,1}'
:call add(tl, ['a\{3,6}', 'aa siofuh'])
:call add(tl, ['a\{3,6}', 'aaaaa asfoij afaa', 'aaaaa'])
:call add(tl, ['a\{3,6}', 'aaaaaaaa', 'aaaaaa'])
:call add(tl, ['a\{0}', 'asoiuj', ''])
:call add(tl, ['a\{2}', 'aaaa', 'aa'])
:call add(tl, ['a\{2}', 'iuash fiusahfliusah fiushfilushfi uhsaifuh askfj nasfvius afg aaaa sfiuhuhiushf', 'aa'])
:call add(tl, ['a\{2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])
:call add(tl, ['a\{0,}', 'oij sdigfusnf', ''])          " same thing as 'a*'
:call add(tl, ['a\{0,}', 'aaaaa aa', 'aaaaa'])
:call add(tl, ['a\{2,}', 'sdfiougjdsafg'])
:call add(tl, ['a\{2,}', 'aaaaasfoij ', 'aaaaa'])
:call add(tl, ['a\{,0}', 'oidfguih iuhi hiu aaaa', ''])
:call add(tl, ['a\{,5}', 'abcd', 'a'])
:call add(tl, ['a\{,5}', 'aaaaaaaaaa', 'aaaaa'])
:call add(tl, ['a\{}', 'bbbcddiuhfcd', ''])                 " same thing as 'a*'
:call add(tl, ['a\{}', 'aaaaioudfh coisf jda', 'aaaa'])

:call add(tl, ['a\{-0,0}', 'abcdfdoij', '']) 
:call add(tl, ['a\{-0,1}', 'asiubid axxxaaa', ''])      " anti-greedy version of 'a?'
:call add(tl, ['a\{-3,6}', 'aa siofuh'])
:call add(tl, ['a\{-3,6}', 'aaaaa asfoij afaa', 'aaa'])
:call add(tl, ['a\{-3,6}', 'aaaaaaaa', 'aaa'])
:call add(tl, ['a\{-0}', 'asoiuj', ''])
:call add(tl, ['a\{-2}', 'aaaa', 'aa'])
:call add(tl, ['a\{-2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])
:call add(tl, ['a\{-0,}', 'oij sdigfusnf', ''])
:call add(tl, ['a\{-0,}', 'aaaaa aa', ''])
:call add(tl, ['a\{-2,}', 'sdfiougjdsafg'])
:call add(tl, ['a\{-2,}', 'aaaaasfoij ', 'aa'])
:call add(tl, ['a\{-,0}', 'oidfguih iuhi hiu aaaa', ''])
:call add(tl, ['a\{-,5}', 'abcd', ''])
:call add(tl, ['a\{-,5}', 'aaaaaaaaaa', ''])
:call add(tl, ['a\{-}', 'bbbcddiuhfcd', ''])            " anti-greedy version of 'a*'
:call add(tl, ['a\{-}', 'aaaaioudfh coisf jda', ''])

:call add(tl, ['abc\@=', 'abc', 'ab'])
:call add(tl, ['abc\@=cd', 'abcd', 'abcd'])
:call add(tl, ['abc\@=', 'ababc', 'ab'])
:call add(tl, ['abcd\@=e', 'abcd'])                     " will never match, no matter the input text
:call add(tl, ['abcd\@=e', 'any text in here ... '])    " will never match
:call add(tl, ['abc\@!', 'abc'])
:call add(tl, ['abc\@!', 'abd', 'ab'])
:call add(tl, ['c\@<=test', 'abctest', 'test'])
:call add(tl, ['c\@<=test', 'abcdtest'])
:call add(tl, ['c\@<!haha', 'chaha'])
:call add(tl, ['c\@<!haha', 'abcd haha', 'haha'])
:call add(tl, ['xyz\@>cd', 'xyzcd', 'xyzcd'])
:call add(tl, ['xyz\@>cd', 'xyzc'])

:" Test groups of characters
:call add(tl, ['\(abc\)*', 'abcabcabc', 'abcabcabc', 'abc'])
:call add(tl, ['\(ab\)\+', 'abababaaaaa', 'ababab', 'ab'])
:call add(tl, ['\(abaaaaa\)*cd', 'cd', 'cd', ''])
:call add(tl, ['\(test1\)\? \(test2\)\?', 'test1 test3', 'test1 ', 'test1', ''])
:call add(tl, ['\(test1\)\= \(test2\) \(test4443\)\=', ' test2 test4443 yupiiiiiiiiiii', ' test2 test4443', '', 'test2', 'test4443'])
:call add(tl, ['\(\(sub1\) hello \(sub 2\)\)', 'asterix sub1 hello sub 2 obelix', 'sub1 hello sub 2', 'sub1 hello sub 2', 'sub1', 'sub 2'])
:call add(tl, ['\(\(\(yyxxzz\)\)\)', 'abcdddsfiusfyyzzxxyyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz'])

:" Test greedy-ness and lazy-ness
:call add(tl, ['a\{-2,7}','aaaaaaaaaaaaa', 'aa'])
:call add(tl, ['a\{2,7}','aaaaaaaaaaaaaaaaaaaa', 'aaaaaaa'])
:call add(tl, ['\vx(.{-,8})yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz','ayxa','xayzxayz'])
:call add(tl, ['\vx(.*)yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz', 'ayxayzxayzxa',''])
:call add(tl, ['\v(a{1,2}){-2,3}','aaaaaaa','aaaa','aa'])
:call add(tl, ['\v(a{-1,3})+','aa','aa','a'])

:"""" TODO: Write tests for \@ features
:"""" TODO: Write more tests for groups, and submatches

:"""" Debugging tests
:call add(tl, ['\v((ab)+|c*)+', 'abcccaba', 'abcccab', '', 'ab'])
:call add(tl, ['\v(a*)+', 'aaaa', 'aaaa', ''])


:"
:for t in tl
:  let l = matchlist(t[1], t[0])
:" check the match itself
:  if len(l) == 0 && len(t) > 2
:    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", did not match, expected: \"' . t[2] . '\"'
:  elseif len(l) > 0 && len(t) == 2
:    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", match: \"' . l[0] . '\", expected no match'
:  elseif len(t) > 2 && l[0] != t[2]
:    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", match: \"' . l[0] . '\", expected: \"' . t[2] . '\"'
:  else
:    $put ='OK'
:  endif
:  if len(l) > 0
:"   check all the nine submatches
:    for i in range(1, 9)
:      if len(t) <= i + 2
:        let e = ''
:      else
:        let e = t[i + 2]
:      endif
:      if l[i] != e
:        $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", submatch ' . i . ': \"' . l[i] . '\", expected: \"' . e . '\"'
:      endif
:    endfor
:    unlet i
:  endif
:endfor
:unlet t tl e l 
:/^Results/,$wq! test.out
ENDTEST

Results of regexptest:
